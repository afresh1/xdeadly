#!/usr/bin/env perl
use Mojolicious::Lite;

use Mojo::Util qw(url_escape slurp);
use List::Util qw(sum);
use Time::Local qw(timegm);

use lib app->home->rel_dir('lib');
use XDeadly::Article;
use XDeadly::Comment;

use Digest::SHA1;

# Documentation browser under "/perldoc"
plugin 'PODRenderer';

my $data_dir               = 'data';
my $auth_dir               = 'auth';
my $secret                 = 'lw1N0mN0t8a24UR4NY12AT55p/23FxJ9H6+NReXed8nTZJraO0g';
my $num_front_page_stories = 5;
my $num_older_stories      = 5;
my $num_rss_stories        = 10;

helper stories => sub { @{ XDeadly::Article->articles( $data_dir ) } };
helper story => sub {
    my ( $self, $id ) = @_;

    if ( $id =~ m{/} ) {
        return XDeadly::Comment->new( data_dir => $data_dir, id => $id );
    }
    else {
        return XDeadly::Article->new( data_dir => $data_dir, id => $id );
    }
};

helper link_to_post => sub {
    my ( $self, $post ) = @_;
    my $title = $post->subject;
    return $self->link_to( $title => $self->url_with( "/article/$post" ) );
};

helper link_to_author => sub {
    my ( $self, $post ) = @_;

    my $title = $post->name;
    my $href  = $post->href;
    return $title unless $href;

    $href = "http://$href" unless $href =~ m{://}; # because

    return $self->link_to( $title => $href );
};

helper is_new => sub {
    my ($self, $post) = @_;
    return 'XXX FIXME [is_new] XXX';
};

helper usernavbar => sub {
    my ($self) = @_;
    return 'anon_navbar';
};

helper weeklist => sub {
    my ($self) = @_;

    my $made_front_page = $num_front_page_stories;
    my $made_weeklist   = $num_older_stories;

    my $last_shortdate;
    my @stories;
    foreach my $sid ( $self->stories ) {
        next if $made_front_page-- > 0;
        my %story = $self->story_details($sid);

        my @date = split /\s+/, $story{date};
        $story{shortdate} = sprintf "%s, %s %d", @date[ 0 .. 2 ];
        $story{time} = $date[3];

        if ( $story{shortdate} ne $last_shortdate ) {
            $last_shortdate = $story{shortdate};
            last unless $made_weeklist--;
        }

        push @stories, \%story;
    }

    return @stories;
};

helper mode => sub {
    my ($self) = @_;
    my %modes = map { $_ => $_ } qw( expanded flat );

    return $modes{ $self->param('mode') || 'collapsed' } || '';
};

helper comment_template => sub {
    return shift->mode ? 'article_comment' : 'article_comment_collapsed';
};

helper level_diff => sub {
    my ($self, $current, $base) = @_;
    return $current->level - ( $base ? $base->level : 0 );
};

helper indent => sub {
    my ($self, $current, $base) = @_;
    return '' if $self->mode eq 'flat';
    return '<ul>' x $self->level_diff( $current, $base );
};
helper unindent => sub {
    my ($self, $current, $base) = @_;
    return '' if $self->mode eq 'flat';
    return '</ul>' x $self->level_diff( $current, $base );
};

helper navigation => sub {
    my ( $self, $sid, $cid) = @_;

    my @links;

    my $mode = $self->mode;
    my $href = $self->url_with("/article/$sid");

    if ( defined $cid ) {
        return (
            {   href  => $href->clone->path("/article/$cid"),
                title => 'Show Thread',
            },
            {   href  => $href->clone->path("/reply/$cid"),
                title => 'Reply to this comment',
            }
        );
    }

    # XXX This is rather fragile, need to find a better way.
    if ( @{ $self->url_with->path } > 2 ) {
        my $up = $self->url_with->clone;
        pop @{ $up->path };

        my @dir = @{ $up->path };
        shift @dir;
        my %parent = $self->load_post(join '/', @dir);
        my $title = $parent{subject} || '';

        push @links, {
            href  => $up,
            title => "Up: $title",
        };
    }

    push @links, {
        href  => $href->clone->query( mode => 'flat' ),
        title => 'Flattened',
    } unless $mode eq 'flat';

    push @links, {
        href  => $href->clone->query( mode => 'expanded' ),
        title => 'Expanded',
    } unless $mode eq 'expanded';

    # $href->clone->query->remove('mode') returns a Mojo::Parameters object
    my $collapsed_href = $href->clone;
    $collapsed_href->query->remove('mode');
    push @links, {
        href  => $collapsed_href,
        title => 'Collapsed',
    } if $mode;

    if ( $self->current_route('front') ) {
        my $count         = $self->count_comments($sid);
        my $s             = $count eq 1 ? '' : 's';
        my $latest_change = $self->human_time(
            $self->latest_change( { $self->story_details($sid) } ) );

        unshift @links, {
            href => $href->clone,
            title => "$count comment$s $latest_change ago",
        };
    }
    elsif ( $self->current_route('article') ) {
        my $seen_myself = 0;
        my $prev;
        my $next;

        foreach my $current ($self->stories) {
            if ($current eq $sid) {
                $seen_myself = 1;
                next;
            }
            elsif ($seen_myself) {
                $prev = $current;
                last;
            }
            $next = $current;
        }

        if ($prev) {
            my %story = $self->story_details($prev);
            unshift @links, {
                href =>  $self->url_with("/article/$prev"),
                title => "<< $story{subject}",
            };
        }

        if ($next) {
            my %story = $self->story_details($next);
            push @links, {
                href =>  $self->url_with("/article/$next"),
                title => "$story{subject} >>",
            };
        }
    }

    return @links;
};

helper human_time => sub {
    my ( $self, $epoch ) = @_;

    my $name = 'seconds';
    my %time = ( $name => scalar time - $epoch );

    foreach (
        { name => 'minutes', qty => 60 },
        { name => 'hours',   qty => 60 },
        { name => 'days',    qty => 24 },
    ) {
        $time{ $_->{name} } = int $time{$name} / $_->{qty};
        $time{$name}        = int $time{$name} % $_->{qty};
        $name               = $_->{name};
    }

    my $time = '';
    $time = "$time{days}d" if $time{days};
    $time .= sprintf "%d:%02d", $time{hours}, $time{minutes}
        if $time{days} < 5;

    return $time;
};

helper users => sub {
    my ( $self ) = @_;
    my $user_file = app->home->rel_file("$auth_dir/xdeadly.org.passwd");

    my @keys = qw( user group password realname email comment );

    my %users;

    open my $fh, '<', $user_file or die "Couldn't open $user_file: $!";
    while (<$fh>) {
        chomp;
        next if /^\s*\#/;
        my %user;
        @user{@keys} = split /;/;
        $users{ $user{user} } = \%user;
    }
    close $fh;

    return \%users;
};

helper user_hash => sub {
    my ($self, $password) = @_;

    my $sha1 = Digest::SHA1->new;
    $sha1->add( $secret );
    $sha1->add( $password );

    return $sha1->hexdigest;
};

under sub {
    my $self = shift;

    $self->stash( $_ => "XXX FIXME [$_] XXX" ) for qw(
        baseurl
        captcha
        category
        checked_comments
        checked_poll
        checked_type_html
        checked_type_plain
        checked_verbose
        cksum
        date
        dept
        editors
        email
        errata
        excerpt
        form
        href
        items
        link
        name
        navigation
        new
        pid
        poll
        pubdate
        query
        rcsid
        related
        results
        selected_method_and
        selected_method_boolean
        selected_method_or
        selected_sort_revscore
        selected_sort_revtime
        selected_sort_revtitle
        selected_sort_score
        selected_sort_time
        selected_sort_title
        selected_topic_oreilly_weasel
        selected_topic_topic27
        selected_topic_topic30
        selected_topic_topic31
        selected_topic_topic34
        selected_topic_topic35
        selected_topic_topic36
        selected_topic_topic37
        selected_topic_topic38
        selected_topic_topic39
        selected_topic_topic40
        selected_topic_topic42
        selected_topic_topic43
        selected_topic_topicaskobsdj
        selected_topic_topicblog
        selected_topic_topicbsd
        selected_topic_topicbsdtalk
        selected_topic_topicconf
        selected_topic_topiccrypto
        selected_topic_topiceditorial
        selected_topic_topichardware
        selected_topic_topicjava
        selected_topic_topicmail
        selected_topic_topicmobile
        selected_topic_topicnda
        selected_topic_topicnetworking
        selected_topic_topicnews
        selected_topic_topicopenbsd
        selected_topic_topicopenssh
        selected_topic_topicpf2
        selected_topic_topicports
        selected_topic_topicreadme
        selected_topic_topicsecurity
        selected_topic_topicsparc
        selected_topic_topicsysadmin
        subject
        submission
        thres
        time
        title
        usergroup
        vuxml
        yesterday
    );

    return 1;
};

get '/' => sub {
    my ($self) = @_;

    my @stories;
    foreach my $sid ( $self->stories ) {
        last if @stories == $num_front_page_stories;
        my %story = $self->story_details($sid);
        if ( $story{has_more} ) {
            $story{more}
                = 'Read '
                . $self->link_to( more => "/article/$story{sid}" )
                . ' . . .';
        }
        push @stories, \%story;
    }
    $self->stash( front_stories => \@stories );
} => 'front';

get '/about';
get '/errata';
get '/search';

get '/article/:sid' => sub {
    my ($self) = @_;
    my $sid = $self->param('sid');

    $self->stash(
        $self->story_details($sid),
        more     => $self->story_more($sid),
        comments => [ $self->comments($sid) ],
    );
} => 'article';

get '/article/:sid/*cid' => sub {
    my ($self) = @_;
    my $sid = $self->param('sid');
    my $cid = $self->param('cid');

    $self->stash(
        $self->comment_details($sid, $cid),
        comments => [ $self->comments("$sid/$cid") ],
    );
} => 'article';


get '/summary' => [ format => [qw( rss json )] ] => sub {
    my ($self) = @_;

    my @required = qw(
        subject
        link
        department
        pubdate
        body
    );
    my @allowed = ( @required, qw(
        sid
        cid
        date
        name
        host
        has_more
    ) );

    my $clean_it;
    $clean_it = sub {
        my %post = @_;
        my %clean;

        my $id = $post{cid} || $post{sid};
        $clean{link} = $self->url_for("/article/$id")->to_abs;

        foreach my $key (@allowed) {
            next unless exists $post{$key} and defined $post{$key};
            $clean{$key} = $post{$key};
        }

        if ( $post{mod} ) {
            $clean{mod}{count} = $post{mod}{count};
            $clean{mod}{sum}   = $post{mod}{sum};
        }

        @{ $clean{comments} }
            = map +{ $clean_it->( %{$_} ) }, @{ $post{comments} || [] };

        return %clean;
    };

    my @stories;
    foreach my $sid ( $self->stories ) {
        my %story = $clean_it->( $self->story_details($sid) );
        $story{$_} //= undef for @required;
        push @stories, \%story;
        last if @stories == $num_rss_stories;
    }

    return $self->render( json => \@stories )
        if $self->stash('format') eq 'json';

    $self->stash( stories => \@stories );
};

get '/submit';
post '/submit';

get '/deauth';
get '/login';
post '/login';

get '/register';
post '/register';

get '/prefs';
post '/prefs';

get '/submissions';
post '/edit';

app->start;
