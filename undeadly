#!/usr/bin/env perl
use Mojolicious::Lite;

use Mojo::Util qw(url_escape slurp);
use Time::Local qw(timegm);

# Documentation browser under "/perldoc"
plugin 'PODRenderer';

my $data_dir = 'data';
my $num_front_page_stories = 5;
my $num_rss_stories = 10;

helper usernavbar => sub {
    my ($self) = @_;
    return 'anon_navbar';
};

helper stories  => sub { return shift->_posts };
helper _posts  => sub {
    my ($self, $dir) = @_;
    $dir = app->home->rel_dir( join '/', $data_dir, $dir || '' );

    opendir my $dh, $dir or die "Couldn't opendir $dir: $!";
    my @posts
        = sort { $b <=> $a } grep { /^\d+$/ && -d "$dir/$_" } readdir $dh;
    close $dh;

    return @posts;
};

helper story_details => sub {
    my ( $self, $sid ) = @_;

    my $file = "$sid/article";
    my %story = $self->load_post($sid);

    $story{has_more} = -e app->home->rel_file("$data_dir/$file.more");
    $story{more} = '';

    if ($story{name} and $story{href}) {
        my $href = url_escape($story{href});
        $story{name} = "<a href='$href'>$story{name}</a>";
    }

    $story{department} = $story{dept};
    $story{sid}        = $sid;
    $story{topicimg}   = $self->topicimg($story{topic});
    $story{topicquery} = $story{topic};

    return %story;
};

helper comment_details => sub {
    my ( $self, $sid, $cid ) = @_;
    my %post = $self->load_post( "$sid/$cid" );

    return (
        sid        => $sid,
        cid        => $cid,
        department => '',
        more       => '',
        topicquery => '',
        topicimg   => '',
        %post,
    );
};

helper load_post => sub {
    my ($self, $base) = @_;
    my $file;
    my $type;

    foreach (qw( article comment )) {
        $type = $_;
        $file = app->home->rel_file("$data_dir/$base/$type");
        last if -e $file;
    }
    return unless -e $file;

    open my $fh, '<', $file or die "Couldn't open $file: $!";

    my %post = (
        file     => $file,
        comments => [],
        body     => '',
    );

    my $in_body = 0;
    while (<$fh>) {
        chomp;
        if ($in_body) {
            $post{body} .= $_;
        }
        elsif (/^$/) {
            $in_body = 1;
        }
        else {
            my ($key, $value) = split /:\s*/, $_, 2;
            $post{$key} = $value;
        }
    }

    $post{date} .= ' (GMT)' if $post{date};
    $post{comments} = [ $self->comments($base) ];
    $post{mod}      = { $self->mod_points("$base/$type") };

    close $fh;
    return %post;
};

helper story_more => sub {
    my ( $self, $sid ) = @_;

    my $file = app->home->rel_file("$data_dir/$sid/article.more");
    return unless -e $file;
    return slurp($file);
};

helper comments => sub {
    my ( $self, $sid ) = @_;

    my @comments = $self->load_comments($sid);

    my $base_level = $comments[0]->{level} || 0;

    foreach my $comment (@comments) {
        $comment->{template}
            = $base_level == ($comment->{level} || 0)
            ? 'article_comment'
            : $self->comment_template;

        $comment->{indent} = $comment->{unindent} = '';

        if ($self->mode ne 'flat' and defined $comment->{level}) {
            my $current = $comment->{level} - $base_level;
            while ($current) {
                $current--;
                $comment->{indent}   .= '<ul>';
                $comment->{unindent} .= '</ul>';
            }
        }
    }

    return @comments;
};

helper count_comments => sub {
    my ($self, $dir) = @_;
    my $count = 0;

    foreach my $cid ($self->_posts($dir)) {
        $count++;
        $count+= $self->count_comments( "$dir/$cid" );
    }

    return $count;
};

helper mod_points => sub {
    my ($self, $post_file) = @_;
    my $file = app->home->rel_file("$data_dir/$post_file.mod");

    my %mod = (
        file  => $file,
        sum   => 0,
        count => 0,
        votes => {},
    );
    return %mod unless -e $file;

    open my $fh, '<', $file or die "Couldn't open $file: $!";
    while (<$fh>) {
        my ($who, $what) = split /\s+/;

        $mod{votes}{$who} = $what;
        next unless $what;

        $mod{count}++;
        $mod{sum} += $what;
    }
    close $fh;

    return %mod;
};

helper latest_change => sub {
    my ($self, @comments) = @_;
    my $epoch = 0;

    foreach my $comment (@comments) {
        my $try = $self->latest_change( @{ $comment->{comments} } );
        $epoch = $try if $epoch < $try;
        $comment->{epoch} ||= $self->parse_ctime( $comment->{date} );
        $epoch = $comment->{epoch} if $epoch < $comment->{epoch};
    }

    return $epoch;
};

helper load_comments => sub {
    my ($self, $dir) = @_;

    return
        map { $_->{level}++; $_ }
        map { $_, @{ $_->{comments} } }
        map +{ $self->load_comment("$dir/$_") }, $self->_posts($dir);
};

helper load_comment => sub {
    my ($self, $dir) = @_;

    my %comment = $self->load_post($dir);
    $comment{cid}      = $dir;
    $comment{comments} = [ $self->load_comments($dir) ];

    return %comment;
};

helper topicimg => sub {
    my ( $self, $topic ) = @_;

    my %topicext;

    $topicext{$_} = 'gif' for qw(
        oreilly_weasel
        topicbl
        topicbsd
        topiccrypto
        topiceditorial
        topicmail
        topicopenbsd
        topicopenssh
        topicports
    );

    $topicext{$_} = 'png' for qw(
        topic30
        topic30
        topicpf2
        topicreadme
        topicnda
        topicsparc
    );

    my $ext = $topicext{$topic} || 'jpg';

    return "$topic.$ext";
};

helper mode => sub {
    my ($self) = @_;
    my %modes = map { $_ => $_ } qw( expanded flat );

    return $modes{ $self->param('mode') || 'collapsed' } || '';
};

helper comment_template => sub {
    return shift->mode ? 'article_comment' : 'article_comment_collapsed';
};

helper navigation => sub {
    my ( $self, $sid, $cid) = @_;

    my @links;

    my $mode = $self->mode;
    my $href = $self->url_with("/article/$sid");

    if ( defined $cid ) {
        return (
            {   href  => $href->clone->path("/article/$cid"),
                title => 'Show Thread',
            },
            {   href  => $href->clone->path("/reply/$cid"),
                title => 'Reply to this comment',
            }
        );
    }

    # XXX This is rather fragile, need to find a better way.
    if ( @{ $self->url_with->path } > 2 ) {
        my $up = $self->url_with->clone;
        pop @{ $up->path };

        my @dir = @{ $up->path };
        shift @dir;
        my %parent = $self->load_post(join '/', @dir);
        my $title = $parent{subject} || '';

        push @links, {
            href  => $up,
            title => "Up: $title",
        };
    }

    push @links, {
        href  => $href->clone->query( mode => 'flat' ),
        title => 'Flattened',
    } unless $mode eq 'flat';

    push @links, {
        href  => $href->clone->query( mode => 'expanded' ),
        title => 'Expanded',
    } unless $mode eq 'expanded';

    # $href->clone->query->remove('mode') returns a Mojo::Parameters object
    my $collapsed_href = $href->clone;
    $collapsed_href->query->remove('mode');
    push @links, {
        href  => $collapsed_href,
        title => 'Collapsed',
    } if $mode;

    if ( $self->current_route('front') ) {
        my $count         = $self->count_comments($sid);
        my $s             = $count eq 1 ? '' : 's';
        my $latest_change = $self->human_time(
            $self->latest_change( { $self->story_details($sid) } ) );

        unshift @links, {
            href => $href->clone,
            title => "$count comment$s $latest_change ago",
        };
    }
    elsif ( $self->current_route('article') ) {
        my $seen_myself = 0;
        my $prev;
        my $next;

        foreach my $current ($self->stories) {
            if ($current eq $sid) {
                $seen_myself = 1;
                next;
            }
            elsif ($seen_myself) {
                $prev = $current;
                last;
            }
            $next = $current;
        }

        if ($prev) {
            my %story = $self->story_details($prev);
            unshift @links, {
                href =>  $self->url_with("/article/$prev"),
                title => "<< $story{subject}",
            };
        }

        if ($next) {
            my %story = $self->story_details($next);
            push @links, {
                href =>  $self->url_with("/article/$next"),
                title => "$story{subject} >>",
            };
        }
    }

    return @links;
};

helper parse_ctime => sub {
    my ($self, $string) = @_;

    my %months = (
        Jan => 0,
        Feb => 1,
        Mar => 2,
        Apr => 3,
        May => 4,
        Jun => 5,
        Jul => 6,
        Aug => 7,
        Sep => 8,
        Oct => 9,
        Nov => 10,
        Dec => 11,
    );

    my ($wday, $mname, $day, $time, $year) = split /\s+/, $string;
    my ($h, $m, $s) = split /:/, $time;

    return timegm( $s, $m, $h, $day, $months{$mname}, $year );
};

helper human_time => sub {
    my ( $self, $epoch ) = @_;

    my $name = 'seconds';
    my %time = ( $name => scalar time - $epoch );

    foreach (
        { name => 'minutes', qty => 60 },
        { name => 'hours',   qty => 60 },
        { name => 'days',    qty => 24 },
    ) {
        $time{ $_->{name} } = int $time{$name} / $_->{qty};
        $time{$name}        = int $time{$name} % $_->{qty};
        $name               = $_->{name};
    }

    my $time = '';
    $time = "$time{days}d" if $time{days};
    $time .= sprintf "%d:%02d", $time{hours}, $time{minutes}
        if $time{days} < 5;

    return $time;
};

under sub {
    my $self = shift;

    $self->stash( $_ => "XXX FIXME [$_] XXX" ) for qw(
        baseurl
        captcha
        category
        checked_comments
        checked_poll
        checked_type_html
        checked_type_plain
        checked_verbose
        cksum
        date
        dept
        editors
        email
        errata
        excerpt
        form
        href
        items
        link
        name
        navigation
        new
        pid
        poll
        pubdate
        query
        rcsid
        related
        results
        selected_method_and
        selected_method_boolean
        selected_method_or
        selected_sort_revscore
        selected_sort_revtime
        selected_sort_revtitle
        selected_sort_score
        selected_sort_time
        selected_sort_title
        selected_topic_oreilly_weasel
        selected_topic_topic27
        selected_topic_topic30
        selected_topic_topic31
        selected_topic_topic34
        selected_topic_topic35
        selected_topic_topic36
        selected_topic_topic37
        selected_topic_topic38
        selected_topic_topic39
        selected_topic_topic40
        selected_topic_topic42
        selected_topic_topic43
        selected_topic_topicaskobsdj
        selected_topic_topicblog
        selected_topic_topicbsd
        selected_topic_topicbsdtalk
        selected_topic_topicconf
        selected_topic_topiccrypto
        selected_topic_topiceditorial
        selected_topic_topichardware
        selected_topic_topicjava
        selected_topic_topicmail
        selected_topic_topicmobile
        selected_topic_topicnda
        selected_topic_topicnetworking
        selected_topic_topicnews
        selected_topic_topicopenbsd
        selected_topic_topicopenssh
        selected_topic_topicpf2
        selected_topic_topicports
        selected_topic_topicreadme
        selected_topic_topicsecurity
        selected_topic_topicsparc
        selected_topic_topicsysadmin
        subject
        submission
        thres
        time
        title
        usergroup
        vuxml
        weeklist
        yesterday
    );

    return 1;
};

get '/' => sub {
    my ($self) = @_;

    my @stories;
    foreach my $sid ( $self->stories ) {
        my %story = $self->story_details($sid);
        if ( $story{has_more} ) {
            $story{more}
                = 'Read '
                . $self->link_to( more => "/article/$story{sid}" )
                . ' . . .';
        }
        push @stories, \%story;
        last if @stories == $num_front_page_stories;
    }
    $self->stash( front_stories => \@stories );
} => 'front';

get '/about';
get '/errata';
get '/search';

get '/article/:sid' => sub {
    my ($self) = @_;
    my $sid = $self->param('sid');

    $self->stash(
        $self->story_details($sid),
        more     => $self->story_more($sid),
        comments => [ $self->comments($sid) ],
    );
} => 'article';

get '/article/:sid/*cid' => sub {
    my ($self) = @_;
    my $sid = $self->param('sid');
    my $cid = $self->param('cid');

    $self->stash(
        $self->comment_details($sid, $cid),
        comments => [ $self->comments("$sid/$cid") ],
    );
} => 'article';


get '/summary' => [ format => [qw( rss json )] ] => sub {
    my ($self) = @_;

    my @required = qw(
        subject
        link
        department
        pubdate
        body
    );
    my @allowed = @required, qw(
        sid
        cid
        date
        name
        host
        has_more
    );

    my $clean_it;
    $clean_it = sub {
        my %post = @_;
        my %clean;

        my $id = $post{cid} || $post{sid};
        $clean{link} = $self->url_for("/article/$id")->to_abs;

        foreach my $key (@allowed) {
            next unless exists $post{$key} and defined $post{$key};
            $clean{$key} = $post{$key};
        }

        if ( $post{mod} ) {
            $clean{mod}{count} = $post{mod}{count};
            $clean{mod}{sum}   = $post{mod}{sum};
        }

        @{ $clean{comments} }
            = map +{ $clean_it->( %{$_} ) }, @{ $post{comments} || [] };

        return %clean;
    };

    my @stories;
    foreach my $sid ( $self->stories ) {
        my %story = $clean_it->( $self->story_details($sid) );
        $story{$_} //= undef for @required;
        push @stories, \%story;
        last if @stories == $num_rss_stories;
    }

    return $self->render( json => \@stories )
        if $self->stash('format') eq 'json';

    $self->stash( stories => \@stories );
};

get '/submit';
post '/submit';

get '/deauth';
get '/login';
post '/login';

get '/register';
post '/register';

get '/prefs';
post '/prefs';

get '/submissions';
post '/edit';

app->start;
